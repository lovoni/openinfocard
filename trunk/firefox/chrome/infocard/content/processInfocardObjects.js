/*
 * Copyright (c) 2006, Chuck Mortimore - charliemortimore at gmail.com
 * xmldap.org
 * All rights reserved.
 *
 * Some code generated by the greasemokey compiler http://www.letitblog.com/greasemonkey-compiler/
 * Base64 by aardwulf.com
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the names xmldap, xmldap.org, xmldap.com nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function do_infocard(e) {
    var doc = e.originalTarget;
    var icIter = document.evaluate("//object", doc, null, XPathResult.ANY_TYPE, null);
    var ic = icIter.iterateNext();
    while (ic) {

        var type = ic.getAttribute("type");

        if ((type == "application/x-informationcard") || (type == "application/x-informationCard") || (type == "application/infocard")) {

            var form = ic;
            while (form.tagName != "FORM") {

                form = form.parentNode;
            }

            var parent = ic.parentNode;

            var body = document.evaluate("//body", doc, null, XPathResult.ANY_TYPE, null).iterateNext();
            var formElm = doc.createElement("FORM");
            formElm.setAttribute("id", "firefox_infocard_form");
            formElm.setAttribute("method", "post");
            formElm.setAttribute("action", parent.getAttribute("action"));
            var input = doc.createElement("INPUT");
            input.setAttribute("name",ic.getAttribute("name"));
            input.setAttribute("type","hidden");
            formElm.appendChild(input);

            inputs = form.getElementsByTagName("input");
            for (var i = 0; i < inputs.length; i++) {
                var tmpInput = inputs[i];
                var clonedInput = tmpInput.cloneNode(true);
                formElm.appendChild(clonedInput);
            }
            body.appendChild(formElm);


            //TODO - make this work with forms so it's less variable
            //form.addEventListener("submit", handle, false);
            //form.addAttribute("onSubmit", "return debug('works');");

            var img = parent.getElementsByTagName("img")[0];
            img.addEventListener("click", handle, false);
            img.setAttribute("onclick","");

        }

        ic = icIter.iterateNext();

    }
}


function authenticate() {

    var pk11tokendb = Components.classes["@mozilla.org/security/pk11tokendb;1"].createInstance(Components.interfaces.nsIPK11TokenDB);
    var pk11token = pk11tokendb.getInternalKeyToken();
    if ( ! pk11token.isLoggedIn() ) {

        if (pk11token.checkPassword(""))  window.openDialog("chrome://mozapps/content/preferences/changemp.xul","","modal,chrome",null);

        try {
            pk11token.login(true);
        } catch (e) {
            return false;
        }

    }
    return pk11token.isLoggedIn();
}

function handle(aEvent){

    var authenticated = authenticate();

    if (authenticated) {

        var callback;

        var img = aEvent.originalTarget;
        var form = img.parentNode;
        while (form.tagName != "FORM") {

            form = form.parentNode;

        }
        var policy = parseCard(form);

        var certificate = processCert();
        var cert = getDer(certificate);

        policy["cert"] = cert;
        policy["cn"] = certificate.commonName;

        var cardManager = window.openDialog("chrome://infocard/content/cardManager.xul","InfoCard Selector", "modal,chrome",
                            policy, function (callbackData) { callback = callbackData;});


        //modal,,resizable=yes
        if ( callback == null ) return;


        var object = form.getElementsByTagName("object")[0];

        var body = form.parentNode;
        while (body.tagName != "BODY") {

            body = body.parentNode;

        }

        var infocardForm;
        var forms = body.getElementsByTagName("FORM");
        for (var i = 0; i < forms.length; i++) {
            var id = forms[i].getAttribute("id");
            if ( id == "firefox_infocard_form") {
                infocardForm = forms[i];
            }
        }

        var inputIter = infocardForm.getElementsByTagName("input");
        var input = inputIter[0];
        input.setAttribute("value",callback);

        infocardForm.submit();

    }

}



function parseCard(infocard) {

    var policy = [];

    var params = infocard.getElementsByTagName("param");
    for (var i = 0; i < params.length; i++) {
        var name = params[i].getAttribute("Name");
        if ( name == "tokenType") {
	 policy["tokenType"] = params[i].getAttribute("Value");
	} else if ( name == "issuer") {
	 policy["issuer"] = params[i].getAttribute("Value");
	} else if ( name == "requiredClaims") {
	 policy["requiredClaims"] = params[i].getAttribute("Value");
	} else if ( name == "optionalClaims") {
	 policy["optionalClaims"] = params[i].getAttribute("Value");
	} else {
	 debug("Unhandled attribute: " + name);
	}
    }

    return policy;

}

function processCert(){

    var browser = document.getElementById("content");
    var secureUi = browser.securityUI;
    var sslStatusProvider = secureUi.QueryInterface(Components.interfaces.nsISSLStatusProvider);
    var sslStatus = sslStatusProvider.SSLStatus.QueryInterface(Components.interfaces.nsISSLStatus);
    return sslStatus.serverCert;


}

function getDer(cert){

    var length = {};
    var derArray = cert.getRawDER(length);
    var certBytes = '';
    for (var i = 0; i < derArray.length; i++) {
        certBytes = certBytes + String.fromCharCode(derArray[i]);
    }
    return encode64(certBytes);

}



var keyStr = "ABCDEFGHIJKLMNOP" +
             "QRSTUVWXYZabcdef" +
             "ghijklmnopqrstuv" +
             "wxyz0123456789+/" +
             "=";

//Base 64 from aardwulf.com
function encode64(input) {
   var output = "";
   var chr1, chr2, chr3 = "";
   var enc1, enc2, enc3, enc4 = "";
   var i = 0;

   do {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);

      enc1 = chr1 >> 2;
      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
      enc4 = chr3 & 63;

      if (isNaN(chr2)) {
         enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
         enc4 = 64;
      }

      output = output +
         keyStr.charAt(enc1) +
         keyStr.charAt(enc2) +
         keyStr.charAt(enc3) +
         keyStr.charAt(enc4);
      chr1 = chr2 = chr3 = "";
      enc1 = enc2 = enc3 = enc4 = "";
   } while (i < input.length);

   return output;
}


//Base 64 from aardwulf.com
function decode64(input) {
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  var base64test = /[^A-Za-z0-9\+\/\=]/g;
  if (base64test.exec(input)) {
     alert("There were invalid base64 characters in the input text.\n" +
           "Valid base64 characters are A-Z, a-z, 0-9, '+', '/', and '='\n" +
           "Expect errors in decoding.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
     enc1 = keyStr.indexOf(input.charAt(i++));
     enc2 = keyStr.indexOf(input.charAt(i++));
     enc3 = keyStr.indexOf(input.charAt(i++));
     enc4 = keyStr.indexOf(input.charAt(i++));

     chr1 = (enc1 << 2) | (enc2 >> 4);
     chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
     chr3 = ((enc3 & 3) << 6) | enc4;

     output = output + String.fromCharCode(chr1);

     if (enc3 != 64) {
        output = output + String.fromCharCode(chr2);
     }
     if (enc4 != 64) {
        output = output + String.fromCharCode(chr3);
     }

     chr1 = chr2 = chr3 = "";
     enc1 = enc2 = enc3 = enc4 = "";

  } while (i < input.length);

  return output;
}





function debug(msg) {
  var debug = Components.classes["@mozilla.org/consoleservice;1"].getService(Components.interfaces.nsIConsoleService);
  debug.logStringMessage("infocard: " + msg);
}


window.addEventListener("load", function() {
    var appcontent = window.document.getElementById("appcontent");
    if (appcontent) {
        if (!appcontent.greased_infocard) {
            appcontent.greased_infocard = true;
            appcontent.addEventListener("DOMContentLoaded", do_infocard, false);
        }
    }
}, false);
